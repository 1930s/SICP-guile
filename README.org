* SICP in 150 Days. 
With a few exceptions¹, these files contain solutions to every SICP exercise
up to Chapter 4 (I am working on 5 now) as well as some helpful tips, tricks and
boilerplate code to make your SICP experience maximally satisfying.

Despite SICP's reputation as /the/ book on computer programming is tempered by a
few habits which can wear on the reader. One mentioned frequently is exercises
asking for details of code and concepts concerning the that it has defined but
not /specified/. This study guide will collate the skeleton code required for
you to get hacking as well as any pitfalls I personally experienced.

Also, if you are interested in exploit writing, assembly or reverse engineering
"proper" you can also check out my "[[http://www.wiley.com/WileyCDA/WileyTitle/productCd-1118787315,subjectCd-CSJ0.html][Practical Reverse Engineering w/ x86 and the
Windows Kernel]]" study guide and solutions as well.

** How To Do It
**** Getting It
Although the original is [[https://mitpress.mit.edu/sicp/][available online]], I'd recommend you strip down to the
texinfo basics or gear up to a fully-featured experience on the web.
- [[http://sarabander.github.io/sicp/html/4_002e4.xhtml#g_t4_002e4][Sara Bander's SICP (Web)]]
- [[http://zv.github.io/note/sicp-in-texinfo][My Own Instructions (Emacs/Texinfo)]]

**** Tools
I'll shortcircuit my own verbose tendencies I'll demand Emacs. [[http://spacemacs.org/][I use vim
keybindings /in/ Emacs and you can too.]]

**** Language
The original publication uses [[https://www.gnu.org/software/mit-scheme/][MIT Scheme]] an efficient if unimpressive language.
Many readers since have used various Schemes, Lisps and languages pretending to
be either.

Although SICP's exercises have been written for dozens of platforms, the
following are the only ones I've personally confirmed.

| Language  | Convenience | Utilities | Wildness | Popularity | Vanilla Threads | ~set!~ | Notes                                                                               |
|-----------+-------------+-----------+----------+------------+-----------------+--------+-------------------------------------------------------------------------------------|
| Guile     | 5/5         | 2/5       | 1/5      | 1/5        | ✓               | ✓      | Fully featured Lisp used by many programs like GDB as an extension language.        |
| Racket    | 3/5         | 4/5       | 4/5      | 3/5        | ✓               |        | New SAT solvers and dynamic PL researchers have spawned from this schism of scheme. |
| MITScheme | 5/5         | 1/5       | 0/5      | 0/5        | ✓               | ✓      | The Default SICP Choice                                                             |
| LFErlang  | 2/5         | 3/5       | 5/5      | 2/5        |                 |        | An ambitious competitor to Elixir by the co-creator of Erlang                       |
| Clojure   | 1/5         | 5/5       | 5/5      | 5/5        | ✓               |        | Needs no introduction                                                               |

I've left out two very popular choices: [[https://common-lisp.net/][Common Lisp]] and [[https://common-lisp.net/][Chicken Scheme]]. One more
choice that strikes me as a little wild but indeed doable is Javascript.

***** Using a Non-Lisp?
Some online commentators have laid out SICP as having deep homoiconic roots - if
they exist I couldn't detect any (in addition, macros are only referenced obliquely). 

Chapter 4's implementation would no doubt contain appreciable difference however
others have used information gleaned from an earlier chapters to write Sexp
parsers which paints over the most glaring inadeluacies of a Unlisp.

You also risk getting a *completely* different message than the book intended to
convey. 

Caveat Emptor.

** The Core of SICP
*** Techniques
The book covers the following theorectical issues in serious depth, usually
building an application using them.

- Huffman Trees 
- Message Passing and Actor Theory
- Type Dispatch

*** Technology
You will build an implementation of everything on this list if you complete SICP.

- Promises
- Lazy Lists
- Symbolic Computer
- JIT Interpreter (without optimization)
- Constraint Solver
- Generic Methods in OOP 


*** Chapter 1
I'm assuming you are already a programmer and as such you can probably sail
through this one. It's a good chapter but it's also skippable if you aren't
rusty on any of the following.

- Implementing loops with recursive functions
- car/cdr/cons and other lisp list manipulation functions
- The 'highlight' results from Computability theory (Ackermann's function et al)
- The features of the language you plan to use for SICP
- You could implement change counting & pascals triangle without recursively
*** Chapter 2
The chapter covers a lot of ground. I remember the following. If you aren't a
specialist in computer science and also a prodigious Lisp programmer, you simply
cannot skip this chapter.

Some things covered include

- Lambda calculus
- Symbolic Computation & computer algebra systems with automatic integration & differentiation
- Encoding, Decoding and all around learning everything about Huffman Trees from the ground up
- The universality of the ~(list)~ datastructure in Lisp
- Dynamic Programming and hierarchical data structures
- Different ways to achieve language features like type-dispatch, message passing and inheritance

This book starts to give you a few nuggets of profound realization that the book
is known for. It gets even better.
**** 2.4 - Multiple Representation of Abstract Data
This chapter is unusual. It's the least and the *most* important for practice of
programming at large. The chapter justifies and presents simplified summaries of
the implementation details of important programming language features and why they
are useful.

There are only 4 exercises, so you can mostly relax and focus on the content,
although both /2.73/ and /2.75/ show up later.

*** Chapter 3
This chapter is the beginning of the end of standard computing textbook and the
beginning of SICP. If you are already a programmer, Chapter 3 presents some huge
temptations to skip content, the first paragraphs of some chapters give the impression
of covering what seems like already well-worn ground as a programmer - the content of the 
chapters differ wildly from whats "on the tin".

Even if you are familiar, SICP has something of a reputation for taking the
well-worn concepts and turning them inside out to expose their "true" structure [fn:2]. 

An important tip for chapter 3 is *DO NOT USE A LANGUAGE WITHOUT MUTABLE LISTS*:
If you are working with languages without convienent mutable data: I started out
with Racket but was forced to rewrite my work after realizing that Racket's
~mlists~ were not going to cut it for a chapter focused on the use and danger of
mutable structures.

Another important consideration is the parallel programming facilities of your
language, the book demands a true concurrency environemtn in order for some
exercises and examples to work right.

Although these limit you, I recommend Guile without hesitation anyway.

**** 3.34
The center of 3.34 is the constraint solver. Following the books implementation
is slower but does remove any function-to-function mapping confusion. On the other hand,
writing your own saves you some time but requires a bit more non-SICP effort.

***** A Skeleton Constraint Solver Class
The book implements the primary classes of the constraint-solver as
straitforward Lisp functions with closures. Classes let you solve exercises
faster, write fewer lines and be more satisfied with your final result.

The following are example base-classes for the primary classes along with their
entire implementation, which allow method introduced later later in the chapter
such as ~process-new-value~ and ~process-forget-value~ to share implementation
details regardless of if they are operating on an ~adder~ or ~multiplier~.

****** Constraint
[[https://github.com/zv/SICP-guile/blob/232a32fcc6091d4f167ea6c4458ab1e55645f11b/sicp3.scm#L823-L925][Implementation]]

#+BEGIN_SRC scheme
(define-class <constraint> ()
  (lhs #:getter lhs
       #:init-keyword #:lhs)
  (rhs #:getter rhs
       #:init-keyword #:rhs)
  (total #:getter total
         #:init-keyword #:total)
  (operator #:getter constraint-operator)
  (inverse-operator #:getter constraint-inv-operator))
#+END_SRC

****** Connector
[[https://github.com/zv/SICP-guile/blob/232a32fcc6091d4f167ea6c4458ab1e55645f11b/sicp3.scm#L777-L821][Implementation]]

#+BEGIN_SRC scheme
(define-class <connector> ()
  (value #:init-value #f
         #:accessor connector-value
         #:setter set-connector-value)

  (informant #:init-value #f
             #:accessor informant
             #:setter set-informant)

  (constraints #:accessor constraints
               #:setter set-constraints
               #:init-form '()))

(define (make-connector)
  (make <connector>))
#+END_SRC

****** Probe
[[https://github.com/zv/SICP-guile/blob/232a32fcc6091d4f167ea6c4458ab1e55645f11b/sicp3.scm#L918-L933][Implementation]]

#+BEGIN_SRC scheme
(define-class <probe> (<constraint>)
  (name #:getter name
        #:setter set-name
        #:init-keyword #:name)
  (connector #:getter connector
             #:setter set-connector
             #:init-keyword #:connector))

(define (probe name connector)
  (let ((cs (make <probe> #:name name #:connector connector)))
    (connect connector cs) cs))
#+END_SRC

*** Chapter 4
**** What You'll Do
- Write An Evaluator
- write a universally 'lazy' structure
- Create Facilities for "Pattern Matching" ala Erlang.

This chapter is the first where preparation *really* pays off.

As with Chapter 3, Chapter 4 extensively uses destructive operations to maintain
it's variables-only stack.

This means it is *possible* to do Chapter 4 in a language without
first-class mutable datastructs but it's a huge hassle: I can't recommend it.

**** The Test Runner
The book will regularly ask you to rewrite, add or otherwise modify the
internals of an interpreter many times over. Having a testing strategy from
day 1 is absolutely essential to preserving sanity.

It doesn't have to be complex. Even if the only functional tests you write are
copied from the REPL-dialogue presented in the book itself - you are saving
yourself down the road.

**** Code reuse
The evaluators you will implement are the following

- base evaluator
- lazy evaluator
- analyzing evaluator
- amb evaluator

The base and lazy evaluator share many implementation details, as do the
analyzing interpreter and amb evaluator.

I benefitted greatly from simply reusing the results of Exercise 4.3 on all my
evaluators - allowing me to add a new function with a single call.

I personally used the code provided by the book directly and made no
substantiative changes to it's structure. This doesn't preclude you from doing
so, but I would estimate you are adding another 25 hours onto your
time-to-completion of SICP without getting a *whole* lot in return.

**** Arithmetic, Predicates and other "missing" functions.
As I said before, the book has a preponderance of questions that cannot be
plugged into your evaluator, which yields some suboptimal groping in the dark.

No, you did not miss anything, arithmetic, predicates and more were never
mentioned in the book - you can safely add them to the list of primitive
functions.

To make your life easier, just add these.
#+BEGIN_SRC lisp
(append! primitive-procedures
         `((+ ,+) (- ,-) (* ,*) (/ ,/) (abs ,abs)
           (= ,=) (< ,<) (<= ,<=) (> ,>) (> ,>=)
           (not ,not)
           (list ,list)
           (member ,member)
           (display ,display)))
#+END_SRC

Additionally, ~let~ is missing from the `amb` interpreter as well. Just add the
one used by the ~analyze~ evaluator.

**** 4.3 - Variations on a Scheme
The `amb` evaluator presented in 4.3 is far from simple and requires patience and
an eye for detail to work out whats really going on.

** If I could do it all again...
Everyone has regrets, let's hope you have fewer by reading mine.

*** TODO Turns out SICP doesn't include stupid material
So many books have irrelevant exercises, SICP doesnt.
I sped through the end of SICP Chapter 3 - I won't do it again.
*** TODO Pay more attention to Lazy evaluator
*** DONE A case of the or-bores
CLOSED: [2016-08-01 Mon 13:34]
Implementing ~or~, ~and~ and other other connective logical statements in the
=amb= evaluator would really be neat -- I just installed a primitive procedure.

*** TODO Permutations and the Floor Puzzle
Permutations and the generation thereof are one of those strange backwaters of
computer programming that never really manages to fit into the broader scheme
(ha) of knowledge. I've come up with no less than 3 ways to do them over the
years, including counting in base-N (where N is the number of permuted items),
the traditional map-n-slap and other mundane methods.

I always feel guilty not giving an honest effort before looking up an algorithm
online and I always feel somewhat stumped on permutation problems. Sure, I know
the "classic" swap algorithm, I've (obviously) implemented the method for
permuting a list in Chapter 2, but something essential feels like it's getting
left out.

Take Exercise 4.39, which (loosely) is to solve the floor puzzle without using
~amb~ *AND* take advantage of knowledge about the puzzle to make it perform
better than 'depth first'.

*** 4.43 (The boat puzzle)
I ended up looking at someone elses solution here - This one is hard to solve
 *without* resorting "tricks", such as applying eliminative logic beforehand to
 solve the problem. This mixes all sorts of different kinds of representations
 of data and many solutions are incorrect.
*** ~parse_words~
The parse words exercises give you the feeling that something really essential
is being left out. I completed the exercises but I started to get to a really
uncomfortable point, especially in Exercise 4.49 that this was some deep
metaphor for parsing fully-specified grammars.

** TODO Exercises
This is a list of exercises I *haven't* completed for some reason or another.
*** Chapter 4
- 4.32
- 4.33
- 4.34
- 4.44
- 4.47 (started to get unbelievably bored of these exercises)
- 4.48 (started to get unbelievably bored of these exercises)
- 4.49 (started to get unbelievably bored of these exercises)

* Footnotes
[fn:1] Including all exercises asking you to draw with pen and paper as well as those specified above.
[fn:2] Ever wonder how people make calculators and webservers using ONLY
type-inference without ANY instructions specified? Turns out thats actually
fairly simple and you are just going to have to read the whole thing to find
out.
