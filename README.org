* SICP in 150 Days. 
With a few exceptions¹, these files contain solutions to every SICP exercise
up to Chapter 4 (I am working on 5 now) as well as some helpful tips, tricks and
boilerplate code to make your SICP experience maximally satisfying.

Despite SICP's reputation as /the/ book on computer programming is tempered by a
few habits which can wear on the reader. One mentioned frequently is exercises
asking for details of code and concepts concerning the that it has defined but
not /specified/. This study guide will collate the skeleton code required for
you to get hacking as well as any pitfalls I personally experienced.

Also, if you are interested in exploit writing, assembly or reverse engineering
"proper" you can also check out my "[[http://www.wiley.com/WileyCDA/WileyTitle/productCd-1118787315,subjectCd-CSJ0.html][Practical Reverse Engineering w/ x86 and the
Windows Kernel]]" study guide and solutions as well.

** How To Do It
**** Getting It
Although the original is [[https://mitpress.mit.edu/sicp/][available online]], I'd recommend you strip down to the
texinfo basics or gear up to a fully-featured experience on the web.
- [[http://sarabander.github.io/sicp/html/4_002e4.xhtml#g_t4_002e4][Sara Bander's SICP (Web)]]
- [[http://zv.github.io/note/sicp-in-texinfo][My Own Instructions (Emacs/Texinfo)]]

**** Tools
I'll shortcircuit my own verbose tendencies I'll demand Emacs. [[http://spacemacs.org/][I use vim
keybindings /in/ Emacs and you can too.]]

**** Language
The original publication uses [[https://www.gnu.org/software/mit-scheme/][MIT Scheme]] an efficient if unimpressive language.
Many readers since have used various Schemes, Lisps and languages pretending to
be either.

Although SICP's exercises have been written for dozens of platforms, the
following are the only ones I've personally confirmed.

| Language  | Convenience | Utilities | Wildness | Popularity | Vanilla Threads | ~set!~ | Notes                                                                               |
|-----------+-------------+-----------+----------+------------+-----------------+--------+-------------------------------------------------------------------------------------|
| Guile     | 5/5         | 2/5       | 1/5      | 1/5        | ✓               | ✓      | Fully featured Lisp used by many programs like GDB as an extension language.        |
| Racket    | 3/5         | 4/5       | 4/5      | 3/5        | ✓               |        | New SAT solvers and dynamic PL researchers have spawned from this schism of scheme. |
| MITScheme | 5/5         | 1/5       | 0/5      | 0/5        | ✓               | ✓      | The Default SICP Choice                                                             |
| LFErlang  | 2/5         | 3/5       | 5/5      | 2/5        |                 |        | An ambitious competitor to Elixir by the co-creator of Erlang                       |
| Clojure   | 1/5         | 5/5       | 5/5      | 5/5        | ✓               |        | Needs no introduction                                                               |

I've left out two very popular choices: [[https://common-lisp.net/][Common Lisp]] and [[https://common-lisp.net/][Chicken Scheme]]. One more
choice that strikes me as a little wild but indeed doable is Javascript.

***** Using a Non-Lisp?
Some online commentators have laid out SICP as having deep homoiconic roots - if
they exist I couldn't detect any (in addition, macros are only referenced obliquely). 

Chapter 4's implementation would no doubt contain appreciable difference however
others have used information gleaned from an earlier chapters to write Sexp
parsers which paints over the most glaring inadeluacies of a Unlisp.

You also risk getting a *completely* different message than the book intended to
convey. 

Caveat Emptor.

** The Core of SICP
*** Techniques
The book covers the following theorectical issues in serious depth, usually
building an application using them.

- Huffman Trees 
- Message Passing and Actor Theory
- Type Dispatch

*** Technology
You will build an implementation of everything on this list if you complete SICP.

- Promises
- Lazy Lists
- Symbolic Computer
- JIT Interpreter (without optimization)
- Constraint Solver
- Generic Methods in OOP 


*** Chapter 1
I'm assuming you are already a programmer and as such you can probably sail
through this one. It's a good chapter but it's also skippable if you aren't
rusty on any of the following.

- Implementing loops with recursive functions
- car/cdr/cons and other lisp list manipulation functions
- The 'highlight' results from Computability theory (Ackermann's function et al)
- The features of the language you plan to use for SICP
- You could implement change counting & pascals triangle without recursively
*** Chapter 2
The chapter covers a lot of ground. I remember the following. If you aren't a
specialist in computer science and also a prodigious Lisp programmer, you simply
cannot skip this chapter.

Some things covered include

- Lambda calculus
- Symbolic Computation & computer algebra systems with automatic integration & differentiation
- Encoding, Decoding and all around learning everything about Huffman Trees from the ground up
- The universality of the ~(list)~ datastructure in Lisp
- Dynamic Programming and hierarchical data structures
- Different ways to achieve language features like type-dispatch, message passing and inheritance

This book starts to give you a few nuggets of profound realization that the book
is known for. It gets even better.
**** 2.4 - Multiple Representation of Abstract Data
This chapter is unusual. It's the least and the *most* important for practice of
programming at large. The chapter justifies and presents simplified summaries of
the implementation details of important programming language features and why they
are useful.

There are only 4 exercises, so you can mostly relax and focus on the content,
although both /2.73/ and /2.75/ show up later.

*** Chapter 3
This chapter is the beginning of the end of standard computing textbook and the
beginning of SICP. If you are already a programmer, Chapter 3 presents some huge
temptations to skip content, the first paragraphs of some chapters give the impression
of covering what seems like already well-worn ground as a programmer - the content of the 
chapters differ wildly from whats "on the tin".

Even if you are familiar, SICP has something of a reputation for taking the
well-worn concepts and turning them inside out to expose their "true" structure [fn:2]. 

An important tip for chapter 3 is *DO NOT USE A LANGUAGE WITHOUT MUTABLE LISTS*:
If you are working with languages without convienent mutable data: I started out
with Racket but was forced to rewrite my work after realizing that Racket's
~mlists~ were not going to cut it for a chapter focused on the use and danger of
mutable structures.

Another important consideration is the parallel programming facilities of your
language, the book demands a true concurrency environemtn in order for some
exercises and examples to work right.

Although these limit you, I recommend Guile without hesitation anyway.

**** 3.34
The center of 3.34 is the constraint solver. Following the books implementation
is slower but does remove any function-to-function mapping confusion. On the other hand,
writing your own saves you some time but requires a bit more non-SICP effort.

***** A Skeleton Constraint Solver Class
The book implements the primary classes of the constraint-solver as
straitforward Lisp functions with closures. Classes let you solve exercises
faster, write fewer lines and be more satisfied with your final result.

The following are example base-classes for the primary classes along with their
entire implementation, which allow method introduced later later in the chapter
such as ~process-new-value~ and ~process-forget-value~ to share implementation
details regardless of if they are operating on an ~adder~ or ~multiplier~.

****** Constraint
[[https://github.com/zv/SICP-guile/blob/232a32fcc6091d4f167ea6c4458ab1e55645f11b/sicp3.scm#L823-L925][Implementation]]

#+BEGIN_SRC scheme
(define-class <constraint> ()
  (lhs #:getter lhs
       #:init-keyword #:lhs)
  (rhs #:getter rhs
       #:init-keyword #:rhs)
  (total #:getter total
         #:init-keyword #:total)
  (operator #:getter constraint-operator)
  (inverse-operator #:getter constraint-inv-operator))
#+END_SRC

****** Connector
[[https://github.com/zv/SICP-guile/blob/232a32fcc6091d4f167ea6c4458ab1e55645f11b/sicp3.scm#L777-L821][Implementation]]

#+BEGIN_SRC scheme
(define-class <connector> ()
  (value #:init-value #f
         #:accessor connector-value
         #:setter set-connector-value)

  (informant #:init-value #f
             #:accessor informant
             #:setter set-informant)

  (constraints #:accessor constraints
               #:setter set-constraints
               #:init-form '()))

(define (make-connector)
  (make <connector>))
#+END_SRC

****** Probe
[[https://github.com/zv/SICP-guile/blob/232a32fcc6091d4f167ea6c4458ab1e55645f11b/sicp3.scm#L918-L933][Implementation]]

#+BEGIN_SRC scheme
(define-class <probe> (<constraint>)
  (name #:getter name
        #:setter set-name
        #:init-keyword #:name)
  (connector #:getter connector
             #:setter set-connector
             #:init-keyword #:connector))

(define (probe name connector)
  (let ((cs (make <probe> #:name name #:connector connector)))
    (connect connector cs) cs))
#+END_SRC

*** Chapter 4
This chapter centers around the creation of a number of Scheme evaluators and is
widely recognized as the most substantial chapter. The regularity with which it
revises it's own ideas make a testing framework and a few utility functions a
profitable use of your time.
 
If you've chosen a language that stresses immutability (like Racket or Clojure)
you'll have a fair amount of extra work.

You'll accomplish the following here:

- Simple Evaluator
  - Implement a variable-only '/stack/' without stored function pointers. 
  - Implement Type-Dispatching Evaluator
  - Implement all major features of scheme used thus far
    - Various forms of ~let~
    - ~letrec~
    - ~cond~
    - Predicates
    - etc.
  - Simultaneous vs. Ordered ~define~
  - The Implementation of Closures
- Just-in-Time Interpreter/Compiler (the 'analyzer')
  - Challenges of a JIT
- Lazy Evaluator
  - Differences between lazy variables and a lazy interpreter
  - Relationship to the promise functions ~force~ and ~delay~
  - Build a model of side-effects in lazy (or otherwise) evaluators
  - Implementation and use of '[[https://en.wikipedia.org/wiki/Thunk][thunks]]'
  - Permitting choice by adding lazy features to basic eval
- "Nondeterministic" Logic Evaluator
  - Apply our earlier DFS with backtracking knowledge to build logic solvers
  - Implement a system of closures for tracking logic unification state
  - Understanding rule-oriented (as opposed to procedure-oriented) computing
  - Simplify problems to their essential logical form (and solve them)
  - Implementation of 'Pattern Matching' ala Erlang
  - A "true" parser
    - Specify a grammar for natural language
    - ...and then writing something that emits all possible sentences
  - Use a random evaluator to explore choices in a truly nondeterministic fashion
 
**** Testing
Starting with a testing strategy is essential to preserving sanity here; I
recommend using the input → result REPL 'dialogues' listed in the text to ensure
that you are conforming to the features that the authors expect you to use in the 
coming exercises.

***** The Test Runner
The default Guile test runner will output a =.log= file to your current directory
instead of printing errors to =stdout=. This is an example test-runner that allows
for more immediate testing.

#+BEGIN_SRC scheme
(use-modules (srfi srfi-64))
(define (sicp-evaluator-runner)
  (let* ((runner (test-runner-null))
         (num-passed 0)
         (num-failed 0))
    (test-runner-on-test-end! runner
      (lambda (runner)
        (case (test-result-kind runner)
          ((pass xpass) (set! num-passed (+ num-passed 1)))
          ((fail xfail)
           (begin
             (let
                 ((rez (test-result-alist runner)))
               (format #t
                       "~a::~a\n Expected Value: ~a | Actual Value: ~a\n Error: ~a\n Form: ~a\n"
                       (assoc-ref rez 'source-file)
                       (assoc-ref rez 'source-line)
                       (assoc-ref rez 'expected-value)
                       (assoc-ref rez 'actual-value)
                       (assoc-ref rez 'actual-error)
                       (assoc-ref rez 'source-form))
               (set! num-failed (+ num-failed 1)))))
          (else #t))))
    (test-runner-on-final! runner
      (lambda (runner)
        (format #t "Passed: ~d || Failed: ~d.~%"
                num-passed num-failed)))
    runner))

(test-runner-factory
 (lambda () (sicp-evaluator-runner)))
#+END_SRC

***** ~test-eval~ Macro
This simple macro allows you to directly extract the expected/result pairs from
the REPL excerpts.
#+BEGIN_SRC scheme
 ;; Standard Evaluator Tests
(define-syntax test-eval
  (syntax-rules (=> test-environment test-equal)
    ((test-eval expr =>)
     (syntax-error "no expect statement"))
    ((test-eval expr => expect)
     (test-eqv  expect (test-evaluator 'expr test-environment)))
    ((test-eval expr expect)
     (test-eqv  expect (test-evaluator 'expr test-environment)))))
#+END_SRC

***** Unit Tests
Now just add tests! The next section of this guide will show you how to
automatically run tests at sensible points as part of the ~driver-loop~.

#+BEGIN_SRC scheme
(test-begin "Tests") ; Begin our tests
(test-begin "Evaluator") ; Begin evaluator tests
(test-begin "Basic") ; The basic (4.1) evaluator
(define test-environment (setup-environment)) ; Initialize the test environment
(define test-evaluator eval) ; Set the evaluator you wish to use

;; You can choose to use `=>' or not
(test-eval (and 1 2) => 2)

(test-eval
 (let fib-iter ((a 1) (b 0) (count 4))
   (if (= count 0) b
       (fib-iter (+ a b) a (- count 1))))
 => 3)

;; cleanup
(set! test-environment '())

(test-end "Basic")
(test-end "Evaluator")
(test-end "Tests")
#+END_SRC

**** Code Reuse

***** Evaluator

****** Type-dispatch for the core evaluator switch statement
[[http://sarabander.github.io/sicp/html/4_002e1.xhtml#Exercise-4_002e3][Exercise 4.3]] asks you to implement a type-dispatch scheme for the base
evaluator, allowing you to incrementally introduce functionality rather than
rewrite ~eval~ with each new feature. This turns out to be very useful
and I wrote all my evaluators in this style.

The concept is demonstrated here:

#+BEGIN_SRC scheme
(define-class <dispatch-table> ()
  (method-table #:init-value  (make-hash-table)
                #:getter      method-table))

(define (table-ordinal op type)
  (let ((opstr  (symbol->string op))
        (typestr (symbol->string type)))
    (string-append opstr "/" typestr)))

(define-method (get (dt <dispatch-table>) op type)
  (if (and (symbol? op) (symbol? type))
      (hash-ref (method-table dt) (table-ordinal op type))
      #f))

(define-method (put (dt <dispatch-table>) op type item)
  (hash-set! (method-table dt) (table-ordinal op type) item))

(define dispatch-tt (make <dispatch-table>))

(define (install-procedure p)
  "Install a procedure to the base evaluator"
  (put dispatch-tt 'eval ; instead of 'eval
                   (car p) 
                   (cadr p))

...

(install-procedure `(and ,eval-and))

(install-procedure `(let* ,(λ (exp env) (zeval (let*->nested-lets exp) env))))

(install-procedure `(undefine ,eval-undefinition))

(install-procedure `(while ,(λ (exp env) (zeval (make-while exp) env))))
#+END_SRC

****** Driver Loops
Just as you dispatched a procedure specific to an evaluator above, you can do
the same with the ~driver-loop~ implementation provided to each evaluator.

1. You'll want to be able to quickly switch the evaluator invoked by ~driver-loop~ as you progress through the chapter and later chapters have a radically different loop.
2. [[http://www.nongnu.org/geiser/][Geiser]] is a very popular scheme integration module for Emacs Lisp that you will probably use. Like many IDE-integrated IDE's it doesn't deal well with a program that requests user input on =stdin=.
3. You can share more code, even between radically different implementations.

My approach is simple - add an entry to a table of ~driver-loop~ implementations
which are chosen at runtime.

#+BEGIN_SRC scheme
;; This function is what actually gets called to invoke your evaluator's REPL
(define (driver-loop evaluator)
  ((get dispatch-tt 'driver-loop evaluator)))

(define (install-driver-loop evaluator fn)
  "Install a new `driver-loop' REPL"
  (put dispatch-tt 'driver-loop evaluator fn))

; base evaluator implementation from 4.14
(define (base-driver-loop)
  (prompt-for-input ";;; Base(zeval) input:")
  (let ((input (read)))
    (let ((output
           (zeval input
                 the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (base-driver-loop))

;; install the base driver loop
(install-driver-loop 'eval base-driver-loop)

(define inside-repl?
  "A method to determine if we are inside a REPL or being executed directly"
  (eq? #f (assq-ref (current-source-location) 'filename)))

...

;; at the end of the file, you can specify which loop you want to invoke when
;; you run.
(if inside-repl? 'ready ;; we want the repl available ASAP if were inside emacs
    (begin
      ;; load our tests
      (load "test/evaluator.scm")
      ;; start the REPL
      (driver-loop 'amb)))
;;; EOF
#+END_SRC

**** Missing Functions
Many code excerpts from the text cannot be directly used in the evaluator
/provided/ by the book itself. Before you initialize your evaluators environment,
be sure to add the following to your ~primitive-procedures~

#+BEGIN_SRC lisp
(append! primitive-procedures
         `((+ ,+) (- ,-) (* ,*) (/ ,/) (abs ,abs)
           (= ,=) (< ,<) (<= ,<=) (> ,>) (> ,>=)
           (not ,not)
           (list ,list)
           (member ,member)
           (display ,display)))
#+END_SRC

Additionally, ~let~ is missing from the `amb` interpreter as well. Just add the
one used by the ~analyze~ evaluator.

**** 4.3 - Variations on a Scheme
The `amb` evaluator presented in 4.3 is far from simple and requires patience and
an eye for detail to work out whats really going on.

** If I could do it all again...
Everyone has regrets, let's hope you have fewer by reading mine.

*** TODO Turns out SICP doesn't include stupid material
So many books have irrelevant exercises, SICP doesnt.
I sped through the end of SICP Chapter 3 - I won't do it again.
*** TODO Pay more attention to Lazy evaluator
*** DONE A case of the or-bores
CLOSED: [2016-08-01 Mon 13:34]
Implementing ~or~, ~and~ and other other connective logical statements in the
=amb= evaluator would really be neat -- I just installed a primitive procedure.

*** TODO Permutations and the Floor Puzzle
Permutations and the generation thereof are one of those strange backwaters of
computer programming that never really manages to fit into the broader scheme
(ha) of knowledge. I've come up with no less than 3 ways to do them over the
years, including counting in base-N (where N is the number of permuted items),
the traditional map-n-slap and other mundane methods.

I always feel guilty not giving an honest effort before looking up an algorithm
online and I always feel somewhat stumped on permutation problems. Sure, I know
the "classic" swap algorithm, I've (obviously) implemented the method for
permuting a list in Chapter 2, but something essential feels like it's getting
left out.

Take Exercise 4.39, which (loosely) is to solve the floor puzzle without using
~amb~ *AND* take advantage of knowledge about the puzzle to make it perform
better than 'depth first'.

*** Exercise 4.43
I ended up looking at someone elses solution here - This one is hard to solve
 *without* resorting "tricks", such as applying eliminative logic beforehand to
 solve the problem. This mixes all sorts of different kinds of representations
 of data and many solutions are incorrect.
*** ~parse_words~
The parse words exercises give you the feeling that something really essential
is being left out. I completed the exercises but I started to get to a really
uncomfortable point, especially in Exercise 4.49 that this was some deep
metaphor for parsing fully-specified grammars.

** TODO Exercises
This is a list of exercises I *haven't* completed for some reason or another.
*** Chapter 4
- 4.32
- 4.33
- 4.34
- 4.44
- 4.47 (started to get unbelievably bored of these exercises)
- 4.48 (started to get unbelievably bored of these exercises)
- 4.49 (started to get unbelievably bored of these exercises)

* Footnotes
[fn:1] Including all exercises asking you to draw with pen and paper as well as those specified above.
[fn:2] Ever wonder how people make calculators and webservers using ONLY
type-inference without ANY instructions specified? Turns out thats actually
fairly simple and you are just going to have to read the whole thing to find
out.
