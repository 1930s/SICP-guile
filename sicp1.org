* Chapter 1: Building Abstractions with Procedures
  :PROPERTIES:
  :header-args: :results output
  :END:

** Exercises
*** 1.1
    #+BEGIN_QUOTE
    *Exercise 1.1:* Below is a sequence of expressions.  What is the
    result printed by the interpreter in response to each expression?
    Assume that the sequence is to be evaluated in the order in which
    it is presented.
    #+END_QUOTE
**** Answer
     #+BEGIN_SRC scheme
   10                     ; => 10
   (+ 5 3 4)              ; => 12
   (- 9 1)                ; => 8
   (/ 6 2)                ; => 3
   (+ (* 2 4) (- 4 6))    ; => 6
   (define a 3)           ; =>
   (define b (+ a 1))     ; =>
   (+ a b (* a b))        ; => 16
   (= a b)                ; => #f
   (if (and (> b a) (< b (* a b)))
       b
       a)                 ; => 4
   (cond ((= a 4) 6)
         ((= b 4) (+ 6 7 a))
         (else 25))       ; => 16
   (+ 2 (if (> b a) b a)) ; => 6
   (* (cond ((> a b) a)
            ((< a b) b)
            (else -1))
    (+ a 1))              ; => 16
     #+END_SRC
*** 1.2
    #+BEGIN_QUOTE
    *Exercise 1.2:* Translate the following expression into prefix
    form.

    =5 + 4 + (2 - (3 - (6 + 4/5))) รท 3(6 - 2)(2 - 7)=
    #+END_QUOTE
**** Answer
     #+BEGIN_SRC scheme :results value
     (/ (+ 5 4 (- 2 (- 3 (- 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))
     #+END_SRC

     #+RESULTS:
     : -11/50
*** 1.3
    #+BEGIN_QUOTE
    *Exercise 1.3:* Define a procedure that takes three numbers as
    arguments and returns the sum of the squares of the two larger
    numbers.
    #+END_QUOTE
**** Answer
     #+BEGIN_SRC  scheme
     (define (square x) (* x x))
     (define (largest-sums x y z)
       (+
        (if (> x y) (square x) (square y))
        (if (> y z) (square y) (square z))))
     #+END_SRC
*** 1.4
    #+BEGIN_QUOTE
    *Exercise 1.4:* Observe that our model of evaluation allows for
    combinations whose operators are compound expressions.  Use this
    observation to describe the behavior of the following procedure:

    =(define (a-plus-abs-b a b)
    ((if (> b 0) + -) a b))=
    #+END_QUOTE
**** Answer
     The expression ~((if (> b 0) + -) a b)~ will evaluate to ~(+ a b)~ if ~b~
     is positive, and ~(- a b)~ otherwise.

*** 1.5
    #+BEGIN_QUOTE
    *Exercise 1.5:* Ben Bitdiddle has invented a test to determine
    whether the interpreter he is faced with is using
    applicative-order evaluation or normal-order evaluation.  He
    defines the following two procedures:

    : (define (p) (p))
    : (define (test x y) (if (= x 0) 0 y))

    Then he evaluates the expression

    : (test 0 (p))

    What behavior will Ben observe with an interpreter that uses
    applicative-order evaluation?  What behavior will he observe with
    an interpreter that uses normal-order evaluation?  Explain your
    answer.  (Assume that the evaluation rule for the special form
    `if' is the same whether the interpreter is using normal or
    applicative order: The predicate expression is evaluated first,
    and the result determines whether to evaluate the consequent or
    the alternative expression.)
    #+END_QUOTE

**** Answer
     Applicative-order interpreters must evaluate the arguments of =(test 0
     (p))= before it can be expanded. =(p)= just evaluates to =(p)=, so
     =(test 0 (p))= is replaced with =(test 0 (p))=
     again. Applicative-order interpreters will never finish evaluating the
     expression, since they will just keep attempting to evaluate before
     expanding.

     Normal-order interpreters will expand the expression as much as
     possible before beginning to reduce it. So they will expand =(test 0
     (p))= to =(if (= 0 0) 0 (p))=, then reduce it to =(if #t 0 (p))=, then to =0=.


*** 1.6

    #+BEGIN_QUOTE
    *Exercise 1.6:* Alyssa P. Hacker doesn't see why ~if~ needs to be
    provided as a special form.  "Why can't I just define it as an
    ordinary procedure in terms of ~cond~?" she asks.  Alyssa's friend
    Eva Lu Ator claims this can indeed be done, and she defines a new
    version of ~if~:

    : (define (new-if predicate then-clause else-clause)
    : (cond (predicate then-clause)
    : (else else-clause)))

    Eva demonstrates the program for Alyssa:

    : (new-if (= 2 3) 0 5)
    : 5

    : (new-if (= 1 1) 0 5)
    : 0

    Delighted, Alyssa uses ~new-if~ to rewrite the square-root program:

    : (define (sqrt-iter guess x)
    : (new-if (good-enough? guess x)
    :     guess
    : (sqrt-iter (improve guess x)
    :     x)))

    What happens when Alyssa attempts to use this to compute square
    roots?  Explain.
    #+END_QUOTE

**** Answer
     =new-if= isn't a special form, so all its arguments will be evaluated
     before expansion to its definition in terms of =cond=. Since one of
     its arguments is a recursive call to =sqrt-iter=, the evaluation will
     never stop.

*** 1.7
    #+BEGIN_QUOTE
    *Exercise 1.7:* The ~good-enough?~ test used in computing square
    roots will not be very effective for finding the square roots of
    very small numbers.  Also, in real computers, arithmetic operations
    are almost always performed with limited precision.  This makes
    our test inadequate for very large numbers.  Explain these
    statements, with examples showing how the test fails for small and
    large numbers.  An alternative strategy for implementing
    ~good-enough?~ is to watch how ~guess~ changes from one iteration
    to the next and to stop when the change is a very small fraction
    of the guess.  Design a square-root procedure that uses this kind
    of end test.  Does this work better for small and large numbers?
    #+END_QUOTE

**** Answer
     The =good-enough?= test will be less effective for small numbers
     because the acceptable error, 0.001, is large relative to small
     numbers.

     The test will be ineffective (or fail entirely) for large numbers with
     limited precision, because a large number =x= +/- 0.001 is still =x=
     at low enough precision.

     A =good-enough?= function using fractions of the guess instead of a
     constant to determine when to stop:

     #+BEGIN_SRC scheme
  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) (/ x 1000)))
     #+END_SRC

     The new =sqrt-iter= performs much better on small numbers:

     #+BEGIN_EXAMPLE
        (old-sqrt-iter 1 0.001)
     => 0.04124542607499115
        (sqrt-iter 1 0.001)
     => 0.03162278245070105
     #+END_EXAMPLE

     And on large numbers:

     #+BEGIN_EXAMPLE
     (sqrt-iter 1 1000000000000000)
     => 31635794.320938785
     (old-sqrt-iter 1 1000000000000000)
     => <loops forever>
     #+END_EXAMPLE

*** 1.8
    #+BEGIN_QUOTE
    *Exercise 1.8:* Newton's method for cube roots is based on the
    fact that if y is an approximation to the cube root of x, then a
    better approximation is given by the value

    :     x/y^2 + 2y
    :     ----------
    :         3

    Use this formula to implement a cube-root procedure analogous to
    the square-root procedure.  (In section *Note 1-3-4:: we will see
    how to implement Newton's method in general as an abstraction of
    these square-root and cube-root procedures.)
    #+END_QUOTE

**** Answer
     #+BEGIN_SRC scheme
  (define (good-enough-cuberoot? guess x)
      (< (abs (- (* guess guess guess) x)) (/ x 1000)))
  
  (define (improve-cuberoot guess x)
    (/ (+ (/ x (* guess guess)) (* 2 guess)) 3))
  
  (define (cube-root-iter guess x)
    (if (good-enough-cuberoot? guess x)
        guess
        (cube-root-iter (improve-cuberoot guess x) x)))
  
  (define (cube-root x)
    (cube-root-iter 1.0 x))
     #+END_SRC

